<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AstroCalendar Pro - GREG.MECH</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        zinc: { 950: '#09090b' }
                    }
                }
            }
        }
    </script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Astronomy Engine -->
    <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@300;400;700;900&display=swap');
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #52525b; }
        
        .loading-overlay {
            background: rgba(9, 9, 11, 0.98);
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body class="bg-zinc-950 text-zinc-100 h-screen overflow-hidden flex flex-col font-sans selection:bg-orange-500/30">
    
    <!-- Loader -->
    <div id="loader" class="absolute inset-0 z-50 flex flex-col items-center justify-center loading-overlay transition-opacity duration-500">
        <div class="w-12 h-12 border-4 border-orange-500 border-t-transparent rounded-full animate-spin mb-4"></div>
        <div class="font-mono text-sm text-orange-500 animate-pulse" id="loader-text">CALCUL ASTRONOMIQUE...</div>
    </div>

    <!-- Main App -->
    <div id="app" class="flex-1 flex flex-col lg:flex-row h-full w-full overflow-hidden relative opacity-0 transition-opacity duration-500"></div>
    
    <!-- Home Button -->
    <a href="index.html" class="absolute bottom-6 left-6 z-50 p-3 bg-zinc-900/90 backdrop-blur border border-zinc-700 rounded-full hover:border-orange-500 text-zinc-400 hover:text-orange-500 transition-all group shadow-lg">
        <i data-lucide="home" class="w-6 h-6 group-hover:scale-110 transition-transform"></i>
    </a>

    <script>
        // --- CONSTANTS ---
        const PLANETS = [
            { name: 'Mercure', id: 'Mercury', type: 'Inner', color: 'text-zinc-400' },
            { name: 'Vénus', id: 'Venus', type: 'Inner', color: 'text-yellow-200' },
            { name: 'Mars', id: 'Mars', type: 'Outer', color: 'text-red-400' },
            { name: 'Jupiter', id: 'Jupiter', type: 'Outer', color: 'text-orange-300' },
            { name: 'Saturne', id: 'Saturn', type: 'Outer', color: 'text-yellow-600' },
            { name: 'Uranus', id: 'Uranus', type: 'Outer', color: 'text-cyan-300' },
            { name: 'Neptune', id: 'Neptune', type: 'Outer', color: 'text-blue-500' }
        ];

        const WEEK_DAYS = ['LUN', 'MAR', 'MER', 'JEU', 'VEN', 'SAM', 'DIM'];
        const MONTHS = ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'];

        // --- STATE ---
        let state = {
            viewDate: new Date(),
            selectedDate: new Date(),
            coords: { lat: 48.8566, lon: 2.3522, name: "Paris" },
            eventsCache: {},
        };

        // --- HELPER FUNCTIONS ---

        // Calcul manuel de la magnitude d'un vecteur (remplace VectorLength qui n'existe pas)
        function vecMagnitude(v) {
            return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
        }

        // Obtient la Longitude Écliptique Géocentrique Relative au Soleil
        // C'est LA fonction clé qui a été corrigée pour utiliser GeoVector + Ecliptic
        function GetRelativeLongitude(bodyId, time) {
            // 1. Vecteur Géocentrique de l'astre (J2000)
            const vBody = Astronomy.GeoVector(bodyId, time, true); 
            // 2. Vecteur Géocentrique du Soleil
            const vSun = Astronomy.GeoVector(Astronomy.Body.Sun, time, true);
            
            // 3. Conversion en Coordonnées Écliptiques
            const eBody = Astronomy.Ecliptic(vBody);
            const eSun = Astronomy.Ecliptic(vSun);
            
            // 4. Différence de longitude
            let diff = eBody.elon - eSun.elon;
            
            // Normalisation 0-360
            while (diff < 0) diff += 360;
            while (diff >= 360) diff -= 360;
            
            return diff;
        }

        function AnglesInOrder(a, b, c) {
            // Helper pour savoir si un angle cible 'b' est compris entre 'a' et 'c' (en tenant compte du passage 360->0)
            a = a % 360; if (a < 0) a += 360;
            b = b % 360; if (b < 0) b += 360;
            c = c % 360; if (c < 0) c += 360;
            
            const MARGIN = 45.0;
            if (c < a) { let temp = a; a = c; c = temp; } // Swap pour simplifier
            
            // Cas normal ou cas "passage par zéro"
            if (a <= MARGIN && c >= 360.0 - MARGIN) {
                return (b >= 0 && b <= a) || (b >= c && b <= 360);
            } else if (c - a <= 2 * MARGIN) {
                return (a <= b && b <= c);
            }
            return false;
        }

        // Recherche binaire du moment exact d'une transition (ex: passage à 180°)
        function FindTransition(start, end, getValueFunc, targetValue) {
            let t1 = start;
            let t2 = end;
            let v1 = getValueFunc(t1);
            let v2 = getValueFunc(t2);
            
            // Gestion du saut 359->0
            if (Math.abs(v1 - v2) > 180) {
                if (v1 > v2) v1 -= 360; else v2 -= 360;
            }

            for(let i=0; i<20; i++) { 
                let mid = new Date((t1.getTime() + t2.getTime()) / 2);
                let vMid = getValueFunc(mid);
                if (Math.abs(vMid - v2) > 180) vMid -= 360;

                let tVal = targetValue;
                if (Math.abs(v1 - tVal) > 180) tVal -= 360;

                if ((v1 <= tVal && vMid >= tVal) || (v1 >= tVal && vMid <= tVal)) {
                    t2 = mid; v2 = vMid;
                } else {
                    t1 = mid; v1 = vMid;
                }
            }
            return new Date((t1.getTime() + t2.getTime()) / 2);
        }

        // Recherche du minimum de séparation (pour les conjonctions)
        function FindMinSeparation(start, end, body1, body2) {
            let a = start.getTime();
            let b = end.getTime();
            const phi = (1 + Math.sqrt(5)) / 2;
            let c = b - (b - a) / phi;
            let d = a + (b - a) / phi;
            
            const getSep = (tMs) => {
                const t = new Date(tMs);
                const v1 = Astronomy.GeoVector(body1, t, true);
                const v2 = Astronomy.GeoVector(body2, t, true);
                return Astronomy.AngleBetween(v1, v2);
            };

            for (let i=0; i<20; i++) {
                if (getSep(c) < getSep(d)) {
                    b = d; d = c; c = b - (b - a) / phi;
                } else {
                    a = c; c = d; d = a + (b - a) / phi;
                }
            }
            const time = new Date((a + b) / 2);
            return { time: time, angle: getSep(time) };
        }

        function getSeparation(body1, body2, time) {
            const v1 = Astronomy.GeoVector(body1, time, true);
            const v2 = Astronomy.GeoVector(body2, time, true);
            return Astronomy.AngleBetween(v1, v2);
        }

        function addEvent(events, date, data) {
            if (!date) return;
            const key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
            if (!events[key]) events[key] = [];
            if (!events[key].some(e => e.name === data.name)) events[key].push(data);
        }

        // --- ENGINE ---

        function calculateEvents(year, month) {
            const events = {};
            const scanStart = new Date(year, month, -5);
            const scanEnd = new Date(year, month + 2, 5);

            try {
                // 1. PHASES LUNAIRES
                let t = new Date(scanStart);
                while (t < scanEnd) {
                    const tNext = new Date(t.getTime() + 86400000);
                    const l1 = GetRelativeLongitude(Astronomy.Body.Moon, t);
                    const l2 = GetRelativeLongitude(Astronomy.Body.Moon, tNext);
                    
                    const phases = [
                        {v:0, n:'Nouvelle Lune', i:'circle'},
                        {v:90, n:'Premier Quartier', i:'circle-dashed'},
                        {v:180, n:'Pleine Lune', i:'circle-dot'},
                        {v:270, n:'Dernier Quartier', i:'circle-dashed'}
                    ];

                    phases.forEach(p => {
                        if (AnglesInOrder(l1, p.v, l2)) {
                            const exactTime = FindTransition(t, tNext, (x) => GetRelativeLongitude(Astronomy.Body.Moon, x), p.v);
                            addEvent(events, exactTime, { type: 'Phase', name: p.n, icon: p.i, time: exactTime, priority: 1 });
                        }
                    });
                    t = tNext;
                }

                // 2. APSIDES (Périgée/Apogée)
                t = new Date(scanStart);
                while (t < scanEnd) {
                    const apsis = Astronomy.SearchLunarApsis(t);
                    if (!apsis || apsis.time.date > scanEnd) break;
                    const isPerigee = apsis.dist_km < 380000;
                    addEvent(events, apsis.time.date, {
                        type: 'Apsis', name: isPerigee ? 'Lune Périgée' : 'Lune Apogée',
                        icon: isPerigee ? 'minimize-2' : 'maximize-2',
                        details: `${Math.round(apsis.dist_km).toLocaleString()} km`, priority: 3
                    });
                    t = new Date(apsis.time.date.getTime() + 86400000);
                }

                // 3. PLANETES (Oppositions & Conjonctions Solaires)
                PLANETS.forEach(p => {
                    const body = Astronomy.Body[p.id];
                    
                    let t = new Date(scanStart);
                    while (t < scanEnd) {
                        const tNext = new Date(t.getTime() + 86400000);
                        const l1 = GetRelativeLongitude(body, t);
                        const l2 = GetRelativeLongitude(body, tNext);

                        // Opposition (180°)
                        if (p.type === 'Outer') {
                            if (AnglesInOrder(l1, 180, l2)) {
                                const exactTime = FindTransition(t, tNext, (x) => GetRelativeLongitude(body, x), 180);
                                addEvent(events, exactTime, { type: 'Opposition', name: `Opposition ${p.name}`, icon: 'circle-off', priority: -1, details: 'Alignement S-T-P' });
                            }
                        }

                        // Conjonction Solaire (0°)
                        if (AnglesInOrder(l1, 0, l2)) {
                            const exactTime = FindTransition(t, tNext, (x) => GetRelativeLongitude(body, x), 0);
                            
                            let name = `Conjonction ${p.name}`;
                            let details = 'Avec le Soleil';
                            
                            if (p.type === 'Inner') {
                                const v = Astronomy.GeoVector(body, exactTime, true);
                                const dist = vecMagnitude(v);
                                const isInf = dist < 1.0;
                                name = `Conj. ${isInf ? 'Inférieure' : 'Supérieure'} ${p.name}`;
                                details = isInf ? 'Passe devant' : 'Passe derrière';
                            }

                            addEvent(events, exactTime, { type: 'Conjunction', name, icon: 'sun', priority: 2, details });
                        }
                        t = tNext;
                    }
                });

                // 4. CONJONCTIONS VISUELLES (Scanner de Minima)
                const bodies = [
                    {id: Astronomy.Body.Moon, name: 'Lune'},
                    {id: Astronomy.Body.Mercury, name: 'Mercure'},
                    {id: Astronomy.Body.Venus, name: 'Vénus'},
                    {id: Astronomy.Body.Mars, name: 'Mars'},
                    {id: Astronomy.Body.Jupiter, name: 'Jupiter'},
                    {id: Astronomy.Body.Saturn, name: 'Saturne'},
                    {id: Astronomy.Body.Uranus, name: 'Uranus'}
                ];

                let tGrid = new Date(scanStart);
                const stepMs = 21600000; // 6h
                
                while(tGrid < scanEnd) {
                    const tNext = new Date(tGrid.getTime() + stepMs);
                    
                    for(let i=0; i<bodies.length; i++) {
                        for(let j=i+1; j<bodies.length; j++) {
                            const b1 = bodies[i];
                            const b2 = bodies[j];
                            
                            const d1 = getSeparation(b1.id, b2.id, tGrid);
                            const d2 = getSeparation(b1.id, b2.id, tNext);
                            
                            const hasMoon = (b1.id === Astronomy.Body.Moon);
                            const coarseThreshold = hasMoon ? 12.0 : 6.0; 

                            // Si on est dans un "creux" ou proche
                            if (d1 < coarseThreshold || d2 < coarseThreshold) {
                                const minInfo = FindMinSeparation(tGrid, tNext, b1.id, b2.id);
                                const visibleThreshold = hasMoon ? 7.0 : 3.5; 
                                
                                if (minInfo.angle <= visibleThreshold) {
                                    addEvent(events, minInfo.time, {
                                        type: 'Conjunction',
                                        name: `${b1.name}/${b2.name}`,
                                        icon: 'users',
                                        details: `${minInfo.angle.toFixed(1)}°`,
                                        priority: 1
                                    });
                                }
                            }
                        }
                    }
                    tGrid = tNext;
                }

            } catch (err) {
                console.error("Erreur critique:", err);
            }

            return events;
        }

        function getDailyData(date, lat, lon) {
            try {
                const observer = new Astronomy.Observer(lat, lon, 0);
                const data = [];
                [Astronomy.Body.Sun, Astronomy.Body.Moon].forEach((body, i) => {
                    const name = i === 0 ? 'Soleil' : 'Lune';
                    const rise = Astronomy.SearchRiseSet(body, observer, +1, date, 1);
                    const set = Astronomy.SearchRiseSet(body, observer, -1, date, 1);
                    if (rise) data.push({ name: `Lever ${name}`, time: rise.date, icon: 'arrow-up', type: 'Rise' });
                    if (set) data.push({ name: `Coucher ${name}`, time: set.date, icon: 'arrow-down', type: 'Set' });
                });
                
                // Planètes visibles uniquement
                const VISIBLE_PLANETS = PLANETS.filter(p => ['Mercury','Venus','Mars','Jupiter','Saturn'].includes(p.id));
                VISIBLE_PLANETS.forEach(p => {
                    const body = Astronomy.Body[p.id];
                    const rise = Astronomy.SearchRiseSet(body, observer, +1, date, 1);
                    const illum = Astronomy.Illumination(body, date);
                    if (rise) data.push({ name: p.name, time: rise.date, icon: 'arrow-up-circle', type: 'Planet', details: `Mag: ${illum.mag.toFixed(1)}`, color: p.color });
                });

                return data.sort((a,b) => a.time - b.time);
            } catch(e) { return []; }
        }

        // --- RENDERER ---

        function render() {
            const app = document.getElementById('app');
            const { viewDate, selectedDate, coords, eventsCache } = state;
            const year = viewDate.getFullYear();
            const month = viewDate.getMonth();
            
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const firstDay = new Date(year, month, 1).getDay();
            const offset = firstDay === 0 ? 6 : firstDay - 1;

            const selectedKey = `${selectedDate.getFullYear()}-${selectedDate.getMonth()}-${selectedDate.getDate()}`;
            const rawEvents = eventsCache[selectedKey] || [];
            
            // Nettoyage doublons (même nom même jour, garde le meilleur)
            const dayEvents = [];
            const map = new Map();
            rawEvents.forEach(e => {
                const k = e.name + (e.details || "");
                if (!map.has(k)) map.set(k, e);
            });
            map.forEach(v => dayEvents.push(v));
            dayEvents.sort((a,b) => a.priority - b.priority);

            const ephemeris = getDailyData(selectedDate, coords.lat, coords.lon);
            let moonIllum = 0;
            try { moonIllum = Astronomy.Illumination(Astronomy.Body.Moon, selectedDate).mag_ratio * 100; } catch(e){}

            const html = `
                <!-- LEFT: CALENDAR -->
                <div class="w-full lg:w-2/3 xl:w-3/4 flex flex-col bg-zinc-950/50 h-full relative">
                    <div class="flex items-center justify-between p-4 border-b border-zinc-800/50 bg-zinc-900/20 backdrop-blur">
                        <div class="flex items-center gap-4">
                            <button onclick="changeMonth(-1)" class="p-2 hover:text-orange-500"><i data-lucide="chevron-left"></i></button>
                            <h2 class="text-2xl font-black uppercase tracking-widest text-zinc-100">
                                ${MONTHS[month]} <span class="text-orange-500 font-mono">${year}</span>
                            </h2>
                            <button onclick="changeMonth(1)" class="p-2 hover:text-orange-500"><i data-lucide="chevron-right"></i></button>
                        </div>
                        <button onclick="goToToday()" class="px-3 py-1 text-xs font-mono border border-zinc-700 rounded hover:border-orange-500">AUJOURD'HUI</button>
                    </div>
                    <div class="grid grid-cols-7 border-b border-zinc-800/50 bg-zinc-900/30">
                        ${WEEK_DAYS.map(d => `<div class="py-2 text-center text-[10px] font-mono text-zinc-500 font-bold">${d}</div>`).join('')}
                    </div>
                    <div class="flex-1 grid grid-cols-7 auto-rows-fr overflow-y-auto bg-zinc-900/10 custom-scrollbar">
                        ${Array(offset).fill('<div class="bg-zinc-950/30 border-b border-r border-zinc-800/30"></div>').join('')}
                        ${Array(daysInMonth).fill(0).map((_, i) => {
                            const d = i + 1;
                            const currentKey = `${year}-${month}-${d}`;
                            const evts = state.eventsCache[currentKey] || [];
                            const isSelected = d === selectedDate.getDate() && month === selectedDate.getMonth();
                            
                            const hasOpp = evts.some(e => e.type === 'Opposition');
                            const hasEclipse = evts.some(e => e.type === 'Eclipse');
                            
                            const disp = [];
                            const s = new Set();
                            evts.forEach(e => { if(!s.has(e.name)){ s.add(e.name); disp.push(e); }});

                            return `
                                <div onclick="selectDate(${d})" 
                                    class="relative group p-1 sm:p-2 border-b border-r border-zinc-800/50 transition-colors cursor-pointer min-h-[90px] flex flex-col justify-between
                                    ${isSelected ? 'bg-orange-500/10 ring-1 ring-inset ring-orange-500/50' : 'hover:bg-zinc-900/40'}">
                                    <div class="flex justify-between items-start w-full">
                                        <span class="text-sm font-bold ${isSelected ? 'text-orange-500' : 'text-zinc-400'}">${d}</span>
                                        <div class="flex gap-1">
                                            ${hasEclipse ? '<span class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></span>' : 
                                              hasOpp ? '<span class="w-2 h-2 rounded-full bg-purple-500 shadow-[0_0_5px_purple]"></span>' : ''}
                                        </div>
                                    </div>
                                    <div class="space-y-0.5 mb-auto mt-1">
                                        ${disp.slice(0, 2).map(e => `
                                            <div class="flex items-center gap-1 text-[9px] text-zinc-500 truncate">
                                                <div class="w-1 h-1 shrink-0 rounded-full ${getEventColor(e.type)}"></div>
                                                <span class="truncate ${e.priority<=1 ? 'text-zinc-300 font-medium' : ''}">${e.name}</span>
                                            </div>
                                        `).join('')}
                                        ${disp.length > 2 ? `<div class="text-[8px] text-zinc-600 pl-2">+${disp.length-2}</div>` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>

                <!-- RIGHT: SIDEBAR -->
                <div class="w-full lg:w-1/3 xl:w-1/4 flex flex-col bg-zinc-950 border-l border-zinc-800 h-full z-10 shadow-2xl">
                    <div class="bg-zinc-900 border-b border-zinc-800 p-4 flex items-center justify-between group cursor-pointer hover:bg-zinc-800 transition" onclick="handleGeo()">
                        <div class="flex items-center gap-3 text-orange-500">
                            <i data-lucide="map-pin" class="w-6 h-6"></i>
                            <div class="flex flex-col">
                                <span class="text-xs font-bold uppercase tracking-wider text-zinc-400">Localisation</span>
                                <span class="text-sm font-bold font-mono text-white truncate max-w-[150px]">${state.coords.name}</span>
                                <span class="text-[10px] font-mono text-zinc-500">${state.coords.lat.toFixed(3)}°N, ${state.coords.lon.toFixed(3)}°E</span>
                            </div>
                        </div>
                    </div>
                    <div class="p-6 border-b border-zinc-800 bg-gradient-to-b from-zinc-900/80 to-zinc-950">
                        <div class="flex justify-between items-start mb-4">
                            <div>
                                <div class="text-5xl font-black text-white tracking-tighter">${selectedDate.getDate()}</div>
                                <div class="text-orange-500 uppercase tracking-widest text-sm font-bold">${MONTHS[selectedDate.getMonth()]}</div>
                            </div>
                            <div class="text-right">
                                <i data-lucide="moon" class="w-10 h-10 text-zinc-400 mb-1 ml-auto" style="fill: rgba(255,255,255,${moonIllum/100})"></i>
                                <div class="text-xs font-mono text-zinc-500">${moonIllum.toFixed(0)}%</div>
                            </div>
                        </div>
                        <div class="space-y-2">
                             ${dayEvents.length === 0 ? '<div class="text-xs text-zinc-600 italic">Aucun événement</div>' : ''}
                             ${dayEvents.map(e => `
                                <div class="p-2 rounded bg-zinc-900/80 border border-zinc-800 flex justify-between items-center group hover:border-zinc-600 transition">
                                    <div class="overflow-hidden">
                                        <span class="font-bold text-xs text-zinc-200 block truncate group-hover:text-white transition">${e.name}</span>
                                        ${e.details ? `<span class="text-[10px] text-zinc-500 truncate block">${e.details}</span>` : ''}
                                    </div>
                                    <i data-lucide="${e.icon}" class="w-4 h-4 ${getTextColor(e.type)} shrink-0 ml-2"></i>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="flex-1 overflow-y-auto p-4 space-y-2 custom-scrollbar">
                        <div class="text-[10px] font-bold uppercase text-zinc-500 tracking-wider mb-2 flex items-center gap-2">
                            <i data-lucide="compass" class="w-3 h-3"></i> Ephémérides
                        </div>
                        ${ephemeris.map(e => `
                            <div class="flex items-center justify-between py-1.5 px-2 border-l-2 border-zinc-800 hover:border-orange-500/50 hover:bg-zinc-900/30 transition group">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="${e.icon}" class="w-3 h-3 ${e.color || 'text-zinc-500'}"></i>
                                    <span class="text-xs font-bold text-zinc-300">${e.name}</span>
                                </div>
                                <div class="text-xs font-mono text-orange-500/80 whitespace-nowrap">${formatTime(e.time)}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            app.innerHTML = html;
            app.classList.remove('opacity-0');
            lucide.createIcons();
        }

        // --- UTILS ---
        function formatTime(date) { if (!date) return ''; return new Date(date).toLocaleTimeString('fr-FR', {hour:'2-digit', minute:'2-digit'}); }
        function getEventColor(type) {
            if (type === 'Opposition') return 'bg-purple-500';
            if (type === 'Conjunction') return 'bg-blue-500';
            if (type === 'Eclipse') return 'bg-red-500';
            return 'bg-zinc-600';
        }
        function getTextColor(type) {
            if (type === 'Opposition') return 'text-purple-400';
            if (type === 'Conjunction') return 'text-blue-400';
            if (type === 'Eclipse') return 'text-red-500';
            return 'text-zinc-500';
        }

        async function updateView() {
            const loader = document.getElementById('loader');
            loader.classList.remove('opacity-0', 'pointer-events-none');
            requestAnimationFrame(() => {
                setTimeout(() => {
                    const y = state.viewDate.getFullYear();
                    const m = state.viewDate.getMonth();
                    state.eventsCache = calculateEvents(y, m);
                    render();
                    loader.classList.add('opacity-0', 'pointer-events-none');
                }, 50);
            });
        }

        window.changeMonth = (d) => { state.viewDate.setMonth(state.viewDate.getMonth() + d); updateView(); };
        window.goToToday = () => { state.viewDate = new Date(); state.selectedDate = new Date(); updateView(); };
        window.selectDate = (d) => { state.selectedDate = new Date(state.viewDate.getFullYear(), state.viewDate.getMonth(), d); render(); };
        window.handleGeo = () => {
            if(navigator.geolocation) {
                document.getElementById('loader').classList.remove('opacity-0', 'pointer-events-none');
                navigator.geolocation.getCurrentPosition(p => {
                    state.coords = {lat: p.coords.latitude, lon: p.coords.longitude, name: 'Local'};
                    updateView();
                }, () => { alert("Erreur Géolocalisation"); document.getElementById('loader').classList.add('opacity-0', 'pointer-events-none'); });
            }
        };

        updateView();
    </script>
</body>
</html>